/*
 * https://github.com/WebAssembly/tool-conventions/blob/main/DynamicLinking.md
 *
 * todo:
 *
 * - threads, tls
 *   it's basically undefined how wasi-threads would interact with
 *   multi-instance setups like this.
 */

#define _DARWIN_C_SOURCE /* snprintf */

#include <assert.h>
#include <errno.h>
#include <inttypes.h>
#include <limits.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "dyld.h"
#include "dyld_impl.h"
#include "dyld_plt.h"
#include "dylink_type.h"
#include "exec_context.h"
#include "fileio.h"
#include "instance.h"
#include "load_context.h"
#include "mem.h"
#include "module.h"
#include "slist.h"
#include "type.h"
#include "util.h"
#include "xlog.h"

static int dyld_load_object_from_file(struct dyld *d, const struct name *name,
                                      const char *filename,
                                      struct dyld_object **objp);
static int dyld_create_shared_resources(struct dyld *d,
                                        const struct memtype *imt);
static int dyld_create_shared_import_objects(struct dyld *d);
static int dyld_adopt_shared_resources(struct dyld *d,
                                       const struct dyld_object *obj);

static const struct name name_GOT_mem = NAME_FROM_CSTR_LITERAL("GOT.mem");
static const struct name name_GOT_func = NAME_FROM_CSTR_LITERAL("GOT.func");
static const struct name name_env = NAME_FROM_CSTR_LITERAL("env");

static const struct name name_table_base =
        NAME_FROM_CSTR_LITERAL("__table_base");
static const struct name name_memory_base =
        NAME_FROM_CSTR_LITERAL("__memory_base");

static const struct name name_table =
        NAME_FROM_CSTR_LITERAL("__indirect_function_table");
static const struct name name_memory = NAME_FROM_CSTR_LITERAL("memory");

static const struct name name_stack_pointer =
        NAME_FROM_CSTR_LITERAL("__stack_pointer");
static const struct name name_heap_base =
        NAME_FROM_CSTR_LITERAL("__heap_base");
static const struct name name_heap_end = NAME_FROM_CSTR_LITERAL("__heap_end");

static const struct name name_main_object = NAME_FROM_CSTR_LITERAL("<main>");

#if defined(TOYWASM_ENABLE_WASM_EXCEPTION_HANDLING)
/*
 * cf.
 * https://github.com/llvm/llvm-project/blob/96c907dbcebdfbc88f73e097270d171bb83ec3cf/llvm/lib/CodeGen/AsmPrinter/WasmException.cpp#L29-L32
 */
static const struct name name_c_longjmp =
        NAME_FROM_CSTR_LITERAL("__c_longjmp");
static const struct name name_cpp_exception =
        NAME_FROM_CSTR_LITERAL("__cpp_exception");

static const uint32_t num_shared_entries = 7;
#else
static const uint32_t num_shared_entries = 5;
#endif

/*
 * __wasm_apply_data_relocs is generated by wasm-ld.
 * it applies relocations to data segments.
 * it's expected to be executed before any application code.
 * (including __wasm_call_ctors/_initialize)
 */
static const struct name reloc_funcs[] = {
        NAME_FROM_CSTR_LITERAL("__wasm_apply_data_relocs"),
};

/*
 * A note about __wasm_call_ctors and _initialize:
 *
 * wasm-ld synthesizes __wasm_call_ctors.
 *
 * wasi reactor exec model uses _initialize as the entry point.
 * crt1 provides _initialize, which calls __wasm_call_ctors.
 * in that case, usually __wasm_call_ctors is not exported.
 * cf. https://reviews.llvm.org/D156205
 *
 * otherwise, wasm-ld exports __wasm_call_ctors as it's
 * the default entry point for -shared.
 *
 * here we assume a module only exports at most one of them.
 */
static const struct name ctor_funcs[] = {
        NAME_FROM_CSTR_LITERAL("_initialize"),
        NAME_FROM_CSTR_LITERAL("__wasm_call_ctors"),
};

static const struct val val_null = {
        .u.funcref.func = NULL,
};

static const struct globaltype globaltype_i32_mut = {
        .t = TYPE_i32,
        .mut = GLOBAL_VAR,
};

static const struct globaltype globaltype_i32_const = {
        .t = TYPE_i32,
        .mut = GLOBAL_CONST,
};

static uint32_t
align_up(uint32_t v, uint32_t align)
{
        uint32_t mask = align - 1;
        return (v + mask) & ~mask;
}

static uint32_t
align_up_log(uint32_t v, uint32_t palign)
{
        uint32_t align = 1 << palign;
        return align_up(v, align);
}

static uint32_t
howmany(uint32_t a, uint32_t b)
{
        return (a + b - 1) / b;
}

static uint32_t
global_get_i32(struct globalinst *ginst)
{
        struct val val;
        global_get(ginst, &val);
        return val.u.i32;
}

static void
global_set_i32(struct globalinst *ginst, uint32_t v)
{
        struct val val;
        val.u.i32 = v;
        global_set(ginst, &val);
}

static bool
is_global_type_i32_const(const struct globaltype *gt)
{
        return gt->mut == GLOBAL_CONST && gt->t == TYPE_i32;
}

static bool
is_global_type_i32_mut(const struct globaltype *gt)
{
        return gt->mut == GLOBAL_VAR && gt->t == TYPE_i32;
}

static bool
is_global_i32_mut_import(const struct module *m, const struct import *im)
{
        if (im->desc.type != EXTERNTYPE_GLOBAL) {
                return false;
        }
        const struct globaltype *gt = &im->desc.u.globaltype;
        return is_global_type_i32_mut(gt);
}

static bool
is_GOT_mem_import(const struct module *m, const struct import *im)
{
        if (!is_global_i32_mut_import(m, im)) {
                return false;
        }
        if (compare_name(&name_GOT_mem, &im->module_name)) {
                return false;
        }
        /* exclude linker-provided names */
        if (!compare_name(&im->name, &name_heap_base) ||
            !compare_name(&im->name, &name_heap_end)) {
                return false;
        }
        return true;
}

static bool
is_GOT_func_import(const struct module *m, const struct import *im)
{
        if (!is_global_i32_mut_import(m, im)) {
                return false;
        }
        if (compare_name(&name_GOT_func, &im->module_name)) {
                return false;
        }
        return true;
}

static bool
is_env_func_import(const struct module *m, const struct import *im)
{
        return im->desc.type == EXTERNTYPE_FUNC &&
               !compare_name(&name_env, &im->module_name);
}

static bool
is_binding_weak(const struct module *m, const struct name *sym)
{
        const struct dylink *dy = m->dylink;
        uint32_t i;
        for (i = 0; i < dy->nimport_info; i++) {
                const struct dylink_import_info *ii = &dy->import_info[i];
                if (compare_name(&ii->module_name, &name_env)) {
                        continue;
                }
                if (compare_name(&ii->name, sym)) {
                        continue;
                }
                return (ii->flags & WASM_SYM_BINDING_WEAK) != 0;
        }
        return false;
}

static bool
is_func_export(const struct module *m, const struct wasm_export *ex)
{
        return ex->desc.type == EXTERNTYPE_FUNC;
}

static bool
is_main_object(struct dyld_object *obj)
{
        struct dyld *dyld = obj->dyld;
        return SLIST_FIRST(&dyld->objs) == obj;
}

void
dyld_options_set_defaults(struct dyld_options *opts)
{
        static const char *paths[] = {"."};

        memset(opts, 0, sizeof(*opts));
        opts->stack_size = 16 * 1024;
        opts->npaths = ARRAYCOUNT(paths);
        opts->paths = paths;
}

void
dyld_init(struct dyld *d, struct mem_context *mctx)
{
        memset(d, 0, sizeof(*d));
        SLIST_HEAD_INIT(&d->objs);
        d->table_base = 0;
        d->memory_base = 0;
        dyld_options_set_defaults(&d->opts);
        d->mctx = mctx;
}

static struct dyld_object *
dyld_find_object_by_name(struct dyld *d, const struct name *name)
{
        struct dyld_object *obj;
        SLIST_FOREACH(obj, &d->objs, q) {
                if (is_main_object(obj)) {
                        continue;
                }
                if (!compare_name(obj->name, name)) {
                        return obj;
                }
        }
        return NULL;
}

int
dyld_search_and_load_object_from_file(struct dyld *d, const struct name *name,
                                      struct dyld_object **objp)
{
        /*
         * perform simple security check.
         *
         * the "name" here can come from untrusted sources:
         * - WASM_DYLINK_NEEDED subsection
         * - dyld:load_object host function
         */
        if (memchr(name->data, 0, name->nbytes) ||
            xstrnstr(name->data, "/", name->nbytes) ||
            xstrnstr(name->data, "..", name->nbytes)) {
                return EPERM;
        }

        const struct dyld_options *opts = &d->opts;
        unsigned int i;
        for (i = 0; i < opts->npaths; i++) {
                char filename[PATH_MAX];
                int ret;
                ret = snprintf(filename, sizeof(filename), "%s/%.*s",
                               opts->paths[i], CSTR(name));
                if (ret == -1) {
                        return errno;
                }
                if (ret >= sizeof(filename)) {
                        return ENAMETOOLONG;
                }
                xlog_trace("dyld: trying to open %s\n", filename);
                ret = dyld_load_object_from_file(d, name, filename, objp);
                if (ret != ENOENT) {
                        return ret;
                }
        }
        return ENOENT;
}

static int
dyld_load_needed_objects(struct dyld *d, struct dyld_object *start)
{
        /*
         * Note: dyld_search_and_load_object_from_file adds a new object
         * to the list we are iterating on.
         */
        int ret = 0;
        struct dyld_object *obj;
        for (obj = start; obj != NULL; obj = SLIST_NEXT(obj, q)) {
                const struct dylink_needs *needs = &obj->module->dylink->needs;
                uint32_t i;
                for (i = 0; i < needs->count; i++) {
                        const struct name *name = &needs->names[i];
                        xlog_trace("dyld: %.*s requires %.*s", CSTR(obj->name),
                                   CSTR(name));
                        if (dyld_find_object_by_name(d, name)) {
                                continue;
                        }
                        ret = dyld_search_and_load_object_from_file(d, name,
                                                                    NULL);
                        if (ret != 0) {
                                xlog_error("failed to load %.*s with %d",
                                           CSTR(name), ret);
                                goto fail;
                        }
                }
        }
fail:
        return ret;
}

static int
dyld_allocate_local_import_object(struct dyld *d, struct dyld_object *obj)
{
        int ret;
        uint32_t nent = 0;

        nent += 2; /* env.__table_base, env.__memory_base */
        nent += obj->ngots;
        nent += obj->nplts;
        ret = import_object_alloc(d->mctx, nent, &obj->local_import_obj);
        if (ret != 0) {
                goto fail;
        }
fail:
        return ret;
}

static int
dyld_create_got(struct dyld *d, struct dyld_object *obj)
{
        int ret;
        const struct module *m = obj->module;
        uint32_t ngots = 0;
        uint32_t nplts = 0;
        uint32_t i;
        for (i = 0; i < m->nimports; i++) {
                const struct import *im = &m->imports[i];
                if (is_GOT_mem_import(m, im)) {
                        ngots++;
                }
                if (is_GOT_func_import(m, im)) {
                        ngots++;
                }
                if (is_env_func_import(m, im)) {
                        nplts++;
                }
        }
        obj->nplts = nplts;
        obj->ngots = ngots;

        ret = dyld_allocate_local_import_object(d, obj);
        if (ret != 0) {
                goto fail;
        }
        struct mem_context *mctx = d->mctx;
        if (nplts > 0) {
                obj->plts = mem_calloc(mctx, nplts, sizeof(*obj->plts));
                if (obj->plts == NULL) {
                        return ENOMEM;
                }
        }
        if (ngots > 0) {
                obj->gots = mem_calloc(mctx, ngots, sizeof(*obj->gots));
                if (obj->gots == NULL) {
                        return ENOMEM;
                }
        }

        struct import_object_entry *e = obj->local_import_obj->entries;

        obj->memory_base_global.type = &globaltype_i32_const;
        e->module_name = &name_env;
        e->name = &name_memory_base;
        e->type = EXTERNTYPE_GLOBAL;
        e->u.global = &obj->memory_base_global;
        e++;

        obj->table_base_global.type = &globaltype_i32_const;
        e->module_name = &name_env;
        e->name = &name_table_base;
        e->type = EXTERNTYPE_GLOBAL;
        e->u.global = &obj->table_base_global;
        e++;

        struct globalinst *got = obj->gots;
        struct dyld_plt *plt = obj->plts;

        for (i = 0; i < m->nimports; i++) {
                const struct import *im = &m->imports[i];
                if (is_GOT_mem_import(m, im) || is_GOT_func_import(m, im)) {
                        got->type = &globaltype_i32_mut;

                        e->module_name = &im->module_name;
                        e->name = &im->name;
                        e->type = EXTERNTYPE_GLOBAL;
                        e->u.global = got;

                        got++;
                        e++;
                }
                if (is_env_func_import(m, im)) {
                        plt->sym = &im->name;
                        plt->refobj = obj;

                        struct funcinst *fi = &plt->pltfi;
                        fi->is_host = true;
                        fi->u.host.instance = (void *)plt;
                        fi->u.host.type = &m->types[im->desc.u.typeidx];
                        fi->u.host.func = dyld_plt;

                        e->module_name = &im->module_name;
                        e->name = &im->name;
                        e->type = EXTERNTYPE_FUNC;
                        e->u.func = fi;

                        plt++;
                        e++;
                }
        }

        assert(got == obj->gots + ngots);
        assert(plt == obj->plts + nplts);
        assert(e == obj->local_import_obj->entries +
                            obj->local_import_obj->nentries);
        return 0;
fail:
        return ret;
}

static const struct memtype *
import_memory_type(const struct module *m)
{
        uint32_t i;
        for (i = 0; i < m->nimports; i++) {
                const struct import *im = &m->imports[i];
                if (im->desc.type != EXTERNTYPE_MEMORY) {
                        continue;
                }
                if (compare_name(&im->module_name, &name_env) ||
                    compare_name(&im->name, &name_memory)) {
                        continue;
                }
                return &im->desc.u.memtype;
        }
        return NULL;
}

static int
dyld_allocate_memory(struct dyld *d, uint32_t align, uint32_t sz,
                     uint32_t *resultp)
{
        uint32_t oldbase = d->memory_base;
        uint32_t aligned = align_up_log(oldbase, align);
        uint32_t newbase = aligned + sz;
        assert(newbase >= oldbase);
        const uint32_t page_size = 1 << memtype_page_shift(d->meminst->type);
        uint32_t oldnpg = howmany(oldbase, page_size);
        uint32_t newnpg = howmany(newbase, page_size);
        assert(newnpg >= oldnpg);
        if (newnpg > oldnpg) {
                uint32_t ret = memory_grow(d->meminst, newnpg - oldnpg);
                if (ret == (uint32_t)-1) {
                        return ENOMEM;
                }
                assert(ret == oldnpg);
        }
        d->memory_base = newbase;
        *resultp = aligned;
        return 0;
}

static int
dyld_allocate_table(struct dyld *d, uint32_t align, uint32_t sz,
                    uint32_t *resultp)
{
        uint32_t oldbase = d->table_base;
        uint32_t aligned = align_up_log(oldbase, align);
        uint32_t newbase = aligned + sz;
        assert(newbase >= oldbase);
        if (newbase > oldbase) {
                uint32_t ret =
                        table_grow(d->tableinst, &val_null, newbase - oldbase);
                if (ret == (uint32_t)-1) {
                        return ENOMEM;
                }
                assert(ret == oldbase);
        }
        d->table_base = newbase;
        *resultp = aligned;
        return 0;
}

static int
dyld_allocate_memory_for_obj(struct dyld *d, struct dyld_object *obj)
{
        const struct dylink_mem_info *minfo = &obj->module->dylink->mem_info;
        int ret = dyld_allocate_memory(d, minfo->memoryalignment,
                                       minfo->memorysize, &obj->memory_base);
        if (ret != 0) {
                return ret;
        }
        xlog_trace("dyld: memory allocated for obj %.*s: %08" PRIx32
                   " - %08" PRIx32,
                   CSTR(obj->name), obj->memory_base,
                   obj->memory_base + minfo->memorysize);
        return 0;
}

static int
dyld_allocate_stack(struct dyld *d, uint32_t stack_size)
{
        uint32_t base;
        uint32_t end;
        int ret;
        ret = dyld_allocate_memory(d, 0, stack_size, &base);
        if (ret != 0) {
                return ret;
        }
        /*
         * __stack_pointer should have 16-byte alignment:
         * https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md#the-linear-stack
         */
        assert(16 == 1 << 4);
        ret = dyld_allocate_memory(d, 4, 0, &end);
        if (ret != 0) {
                return ret;
        }
        global_set_i32(d->stack_pointer, end);
        xlog_trace("dyld: stack allocated %08" PRIx32 " - %08" PRIx32, base,
                   end);
        return 0;
}

static int
dyld_allocate_heap(struct dyld *d)
{
        uint32_t base;
        uint32_t end;
        int ret;
        ret = dyld_allocate_memory(d, 0, 0, &base);
        if (ret != 0) {
                return ret;
        }
        /*
         * make __heap_end the next page boundary as LLVM wasm-ld does.
         */
        const uint32_t page_shift = memtype_page_shift(d->meminst->type);
        ret = dyld_allocate_memory(d, page_shift, 0, &end);
        if (ret != 0) {
                return ret;
        }
        global_set_i32(&d->heap_base, base);
        global_set_i32(&d->heap_end, end);
        xlog_trace("dyld: heap allocated %08" PRIx32 " - %08" PRIx32, base,
                   end);
        return 0;
}

static int
dyld_allocate_table_for_obj(struct dyld *d, struct dyld_object *obj)
{
        const struct dylink_mem_info *minfo = &obj->module->dylink->mem_info;
        int ret = dyld_allocate_table(d, minfo->tablealignment,
                                      minfo->tablesize, &obj->table_base);
        if (ret != 0) {
                return ret;
        }
        xlog_trace("dyld: table elem allocated for %.*s (mem_info): %08" PRIx32
                   " - %08" PRIx32,
                   CSTR(obj->name), obj->table_base,
                   obj->table_base + minfo->tablesize);
        return 0;
}

static int
dyld_allocate_table_for_obj_exports(struct dyld *d, struct dyld_object *obj)
{
        /*
         * Note: the following logic likely allocates more than
         * what's actually necessary because:
         *
         * - not all exported functions are actually imported
         * - some of exported functions can refer to the same
         *   function instance.
         */
        const struct module *m = obj->module;
        int ret;
        uint32_t nexports = 0;
        uint32_t i;
        for (i = 0; i < m->nexports; i++) {
                if (is_func_export(m, &m->exports[i])) {
                        nexports++;
                }
        }
        ret = dyld_allocate_table(d, 0, nexports, &obj->table_export_base);
        if (ret != 0) {
                return ret;
        }
        obj->nexports = nexports;
        xlog_trace("dyld: table elem allocated for %.*s (export): %08" PRIx32
                   " - %08" PRIx32,
                   CSTR(obj->name), obj->table_export_base,
                   obj->table_export_base + nexports);
        return ret;
}

static void
dyld_object_destroy(struct dyld_object *obj)
{
#if 0
        /*
         * obj->name might have been freed given the order dyld_clear()
         * frees objects
         */
        xlog_trace("dyld: destroying %.*s", CSTR(obj->name));
#endif
        struct dyld *d = obj->dyld;
        struct mem_context *mctx = d->mctx;
        if (obj->local_import_obj != NULL) {
                import_object_destroy(mctx, obj->local_import_obj);
        }
        mem_free(mctx, obj->gots, obj->ngots * sizeof(*obj->gots));
        mem_free(mctx, obj->plts, obj->nplts * sizeof(*obj->plts));
        if (obj->instance != NULL) {
                instance_destroy(obj->instance);
        }
        if (obj->module != NULL) {
                module_destroy(&obj->module_mctx, obj->module);
        }
        if (obj->bin != NULL) {
                unmap_file((void *)obj->bin, obj->binsz);
        }
        mem_context_clear(&obj->module_mctx);
        mem_context_clear(&obj->instance_mctx);
        mem_free(mctx, obj, sizeof(*obj));
}

static int
dyld_execute_obj_init_func1(struct dyld_object *obj, const struct name *name)
{
        struct module *m = obj->module;
        uint32_t funcidx;
        int ret;
        ret = module_find_export_func(m, name, &funcidx);
        if (ret != 0) {
                return ret;
        }
        const struct functype *ft = module_functype(m, funcidx);
        const struct resulttype *pt = &ft->parameter;
        const struct resulttype *rt = &ft->result;
        if (pt->ntypes != 0 || rt->ntypes != 0) {
                return EINVAL;
        }
        struct exec_context ectx;
        struct dyld *dyld = obj->dyld;
        exec_context_init(&ectx, obj->instance, dyld->mctx);
        ret = instance_execute_func(&ectx, funcidx, pt, rt);
        /*
         * XXX restart handilng should be left to the user.
         * maybe we can split dyld_load to _no_init and
         * _execute_init, similarly to instance_create.
         */
        ret = instance_execute_handle_restart(&ectx, ret);
        exec_context_clear(&ectx);
        return ret;
}

/*
 * dyld_execute_obj_init_func:
 *
 * execute at most one of the init functions given by the names.
 */
static int
dyld_execute_obj_init_func(struct dyld_object *obj, const struct name *names,
                           size_t nnames)
{
        xlog_trace("dyld: executing init funcs for object %.*s",
                   CSTR(obj->name));
        unsigned int i;
        for (i = 0; i < nnames; i++) {
                const struct name *funcname = &names[i];
                int ret = dyld_execute_obj_init_func1(obj, funcname);
                if (ret == ENOENT) {
                        xlog_trace("dyld: %.*s doesn't have %.*s",
                                   CSTR(obj->name), CSTR(funcname));
                        continue;
                }
                if (ret != 0) {
                        xlog_error("dyld: %.*s %.*s failed with %d",
                                   CSTR(obj->name), CSTR(funcname), ret);
                        return ret;
                }
                xlog_trace("dyld: %.*s %.*s succeeded", CSTR(obj->name),
                           CSTR(funcname));
                break;
        }
        return 0;
}

SLIST_HEAD_NAMED(struct dyld_object, tsort_list);

static void
tsort_visit(struct dyld_object *obj, struct tsort_list *list)
{
        if (obj->visited) {
                return;
        }
        obj->visited = true;

        struct dyld *d = obj->dyld;
        const struct dylink_needs *needs = &obj->module->dylink->needs;
        uint32_t i;
        for (i = 0; i < needs->count; i++) {
                const struct name *name = &needs->names[i];
                struct dyld_object *needed_obj =
                        dyld_find_object_by_name(d, name);
                assert(needed_obj != NULL);
                tsort_visit(needed_obj, list);
        }
        SLIST_INSERT_TAIL(list, obj, tq);
}

int
dyld_execute_all_init_funcs(struct dyld *d, struct dyld_object *start)
{
        /* topological sort */
        struct tsort_list list;
        SLIST_HEAD_INIT(&list);
        struct dyld_object *obj;
        for (obj = start; obj != NULL; obj = SLIST_NEXT(obj, q)) {
                assert(!obj->visited);
        }
        for (obj = start; obj != NULL; obj = SLIST_NEXT(obj, q)) {
                tsort_visit(obj, &list);
        }

        SLIST_FOREACH(obj, &list, tq) {
                int ret = dyld_execute_obj_init_func(obj, reloc_funcs,
                                                     ARRAYCOUNT(reloc_funcs));
                if (ret != 0) {
                        return ret;
                }
        }
        SLIST_FOREACH(obj, &list, tq) {
                int ret = dyld_execute_obj_init_func(obj, ctor_funcs,
                                                     ARRAYCOUNT(ctor_funcs));
                if (ret != 0) {
                        return ret;
                }
        }
        return 0;
}

static int
dyld_load_object_from_file(struct dyld *d, const struct name *name,
                           const char *filename, struct dyld_object **objp)
{
        struct dyld_object *obj;
        int ret;
        obj = mem_zalloc(d->mctx, sizeof(*obj));
        if (obj == NULL) {
                ret = ENOMEM;
                goto fail;
        }
        mem_context_init(&obj->module_mctx);
        obj->module_mctx.parent = d->mctx;
        mem_context_init(&obj->instance_mctx);
        obj->instance_mctx.parent = d->mctx;
        obj->dyld = d;
        obj->name = name;
        ret = map_file(filename, (void *)&obj->bin, &obj->binsz);
        if (ret != 0) {
                goto fail;
        }
        struct load_context lctx;
        load_context_init(&lctx, &obj->module_mctx);
        ret = module_create(&obj->module, obj->bin, obj->bin + obj->binsz,
                            &lctx);
        if (ret != 0) {
                xlog_error("module_create failed with %d: %s", ret,
                           report_getmessage(&lctx.report));
                load_context_clear(&lctx);
                goto fail;
        }
        load_context_clear(&lctx);
        if (obj->module->dylink == NULL) {
                xlog_error("module %.*s doesn't have dylink.0", CSTR(name));
                ret = EINVAL;
                goto fail;
        }
        /*
         * the first object is the main module, which is not necessarily
         * position independent.
         *
         * for pie, we provide memory and table.
         * (this needs to be done before module instantiation)
         *
         * for non-pie, we use memory and table exported from the module.
         * (this needs to be done after module instantiation)
         *
         * here we make a guess;
         * if the module is importing env.memory, probably it's a pie.
         * otherwise, it's probably non-pie.
         */
        bool pie_or_lib;
        if (SLIST_EMPTY(&d->objs)) {
                /* the main module */
                const struct memtype *mt = import_memory_type(obj->module);
                d->pie = pie_or_lib = mt != NULL;
                if (d->pie) {
                        ret = dyld_create_shared_resources(d, mt);
                        if (ret != 0) {
                                goto fail;
                        }
                        ret = dyld_create_shared_import_objects(d);
                        if (ret != 0) {
                                goto fail;
                        }
                }
        } else {
                pie_or_lib = true;
        }
        ret = dyld_create_got(d, obj);
        if (ret != 0) {
                goto fail;
        }
        if (pie_or_lib) {
                ret = dyld_allocate_memory_for_obj(d, obj);
                if (ret != 0) {
                        goto fail;
                }
                ret = dyld_allocate_table_for_obj(d, obj);
                if (ret != 0) {
                        goto fail;
                }
        }
        xlog_trace("dyld: obj %.*s __memory_base %08" PRIx32
                   " __table_base %08" PRIx32,
                   CSTR(name), obj->memory_base, obj->table_base);
        global_set_i32(&obj->memory_base_global, obj->memory_base);
        global_set_i32(&obj->table_base_global, obj->table_base);
        assert(d->shared_import_obj != NULL);
        obj->local_import_obj->next = d->shared_import_obj;
        struct report report;
        report_init(&report);
        ret = instance_create(&obj->instance_mctx, obj->module, &obj->instance,
                              obj->local_import_obj, &report);
        if (ret != 0) {
                xlog_error("instance_create failed with %d: %s", ret,
                           report_getmessage(&report));
                report_clear(&report);
                goto fail;
        }
        report_clear(&report);
        if (!pie_or_lib) {
                /*
                 * non-pie main module should export certain resources.
                 * adopt them.
                 */
                ret = dyld_adopt_shared_resources(d, obj);
                if (ret != 0) {
                        goto fail;
                }
                ret = dyld_create_shared_import_objects(d);
                if (ret != 0) {
                        goto fail;
                }
        }
        ret = dyld_allocate_table_for_obj_exports(d, obj);
        if (ret != 0) {
                goto fail;
        }
        SLIST_INSERT_TAIL(&d->objs, obj, q);
        xlog_trace("dyld: %.*s loaded", CSTR(name));
        if (objp != NULL) {
                *objp = obj;
        }
        return 0;
fail:
        if (obj != NULL) {
                dyld_object_destroy(obj);
        }
        return ret;
}

/*
 * calculate max value for memtype.
 */
static uint32_t
memtype_max(uint64_t limit_in_bytes, uint32_t page_shift)
{
        assert(limit_in_bytes <= WASM_MAX_MEMORY_SIZE);
        assert(limit_in_bytes >> page_shift << page_shift == limit_in_bytes);
        if (limit_in_bytes == WASM_MAX_MEMORY_SIZE && page_shift == 0) {
                /*
                 * Note that:
                 * - (WASM_MAX_MEMORY_SIZE >> 0) doesn't fit uint32_t.
                 * - UINT32_MAX is a logical equivalent of no limit.
                 */
                return UINT32_MAX;
        }
        return limit_in_bytes >> page_shift;
}

static int
dyld_create_shared_resources(struct dyld *d, const struct memtype *imt)
{
        int ret;

        assert(d->pie);
        assert(imt != NULL);

        assert(d->table_base == 0);
        d->table_base = 1; /* do not use the first one */
        struct tabletype *tt = &d->u.pie.tt;
        tt->et = TYPE_funcref;
        tt->lim.min = d->table_base;
        tt->lim.max = UINT32_MAX;
        ret = table_instance_create(d->mctx, &d->tableinst, tt);
        if (ret != 0) {
                goto fail;
        }
        assert(d->memory_base == 0);
#if defined(TOYWASM_ENABLE_WASM_CUSTOM_PAGE_SIZES)
        const uint32_t page_shift = memtype_page_shift(imt);
#else
        const uint32_t page_shift = WASM_PAGE_SHIFT;
#endif
        struct memtype *mt = &d->u.pie.mt;
        const uint32_t page_size = 1 << page_shift;
        mt->lim.min = howmany(d->memory_base, page_size);
        mt->lim.max = memtype_max(WASM_MAX_MEMORY_SIZE, page_shift);
        mt->flags = 0;
#if defined(TOYWASM_ENABLE_WASM_CUSTOM_PAGE_SIZES)
        mt->page_shift = page_shift;
#else
#endif
        ret = memory_instance_create(d->mctx, &d->meminst, mt);
        if (ret != 0) {
                goto fail;
        }

        d->stack_pointer = &d->u.pie.stack_pointer;
        d->stack_pointer->type = &globaltype_i32_mut;
fail:
        return ret;
}

static int
dyld_create_shared_import_objects(struct dyld *d)
{
        int ret;

        d->heap_base.type = &globaltype_i32_mut;
        d->heap_end.type = &globaltype_i32_mut;

#if defined(TOYWASM_ENABLE_WASM_EXCEPTION_HANDLING)
        ret = functype_from_string(d->mctx, "(i)", &d->c_longjmp_ft);
        if (ret != 0) {
                goto fail;
        }
        d->c_longjmp.type = d->c_longjmp_ft;
        d->cpp_exception.type = d->c_longjmp_ft;
#endif

        struct import_object *imp;
        ret = import_object_alloc(d->mctx, num_shared_entries, &imp);
        if (ret != 0) {
                goto fail;
        }

        struct import_object_entry *e = imp->entries;

        e->module_name = &name_env;
        e->name = &name_memory;
        e->type = EXTERNTYPE_MEMORY;
        e->u.mem = d->meminst;
        e++;

        e->module_name = &name_env;
        e->name = &name_table;
        e->type = EXTERNTYPE_TABLE;
        e->u.table = d->tableinst;
        e++;

        e->module_name = &name_env;
        e->name = &name_stack_pointer;
        e->type = EXTERNTYPE_GLOBAL;
        e->u.global = d->stack_pointer;
        e++;

        e->module_name = &name_GOT_mem;
        e->name = &name_heap_base;
        e->type = EXTERNTYPE_GLOBAL;
        e->u.global = &d->heap_base;
        e++;

        e->module_name = &name_GOT_mem;
        e->name = &name_heap_end;
        e->type = EXTERNTYPE_GLOBAL;
        e->u.global = &d->heap_end;
        e++;

#if defined(TOYWASM_ENABLE_WASM_EXCEPTION_HANDLING)
        e->module_name = &name_env;
        e->name = &name_c_longjmp;
        e->type = EXTERNTYPE_TAG;
        e->u.tag = &d->c_longjmp;
        e++;

        e->module_name = &name_env;
        e->name = &name_cpp_exception;
        e->type = EXTERNTYPE_TAG;
        e->u.tag = &d->cpp_exception;
        e++;
#endif

        assert(e == imp->entries + num_shared_entries);
        imp->next = d->shared_import_obj;
        d->shared_import_obj = imp;

#if defined(TOYWASM_ENABLE_DYLD_DLFCN)
        if (d->opts.enable_dlfcn) {
                ret = import_object_create_for_dyld(d->mctx, d, &imp);
                if (ret != 0) {
                        goto fail;
                }
                imp->next = d->shared_import_obj;
                d->shared_import_obj = imp;
        }
#endif
fail:
        return ret;
}

static int
find_global(const struct dyld_object *obj, const struct name *name,
            const struct globaltype *type, struct globalinst **gp)
{
        const struct module *m = obj->module;
        const struct instance *inst = obj->instance;
        uint32_t globalidx;
        int ret;

        ret = module_find_export(m, name, EXTERNTYPE_GLOBAL, &globalidx);
        if (ret != 0) {
                xlog_error("dyld: failed to find global %.*s in %.*s",
                           CSTR(name), CSTR(obj->name));
                return ret;
        }
        struct globalinst *g = VEC_ELEM(inst->globals, globalidx);
        if (g->type->mut != type->mut || g->type->t != type->t) {
                xlog_error("dyld: unexpected type of global %.*s in %.*s",
                           CSTR(name), CSTR(obj->name));
                return EINVAL;
        }
        *gp = g;
        return 0;
}

static int
dyld_adopt_shared_resources(struct dyld *d, const struct dyld_object *obj)
{
        const struct module *m = obj->module;
        const struct instance *inst = obj->instance;
        int ret;

        uint32_t memidx;
        ret = module_find_export(m, &name_memory, EXTERNTYPE_MEMORY, &memidx);
        if (ret != 0) {
                xlog_error("dyld: failed to adopt memory from %.*s",
                           CSTR(obj->name));
                goto fail;
        }
        d->meminst = VEC_ELEM(inst->mems, memidx);
        uint32_t page_shift = memtype_page_shift(d->meminst->type);
        d->memory_base = d->meminst->type->lim.min << page_shift;

        uint32_t tableidx;
        ret = module_find_export(m, &name_table, EXTERNTYPE_TABLE, &tableidx);
        if (ret != 0) {
                xlog_error("dyld: failed to adopt table from %.*s",
                           CSTR(obj->name));
                return ret;
        }
        d->tableinst = VEC_ELEM(inst->tables, tableidx);
        if (d->tableinst->type->et != TYPE_funcref) {
                xlog_error("dyld: unexpected type of table from %.*s",
                           CSTR(obj->name));
                return EINVAL;
        }
        d->table_base = d->tableinst->type->lim.min;

        ret = find_global(obj, &name_stack_pointer, &globaltype_i32_mut,
                          &d->stack_pointer);
        if (ret != 0) {
                return ret;
        }
        ret = find_global(obj, &name_heap_base, &globaltype_i32_const,
                          &d->u.nonpie.heap_base);
        if (ret != 0) {
                return ret;
        }
        ret = find_global(obj, &name_heap_end, &globaltype_i32_const,
                          &d->u.nonpie.heap_end);
        if (ret != 0) {
                return ret;
        }
        return 0;
fail:
        return ret;
}

static uint32_t
dyld_register_funcinst(struct dyld *d, struct dyld_object *obj,
                       const struct funcinst *fi)
{
        struct tableinst *ti = d->tableinst;
        xlog_trace("dyld: registering obj %.*s finst %p", CSTR(obj->name),
                   (void *)fi);
        uint32_t end = obj->table_export_base + obj->nexports;
        /*
         * note that we should avoid creating multiple entries for
         * a single funcinst. otherwise, it would break C function
         * pointer comparisons in wasm.
         *
         * XXX dumb linear search
         */
        uint32_t i;
        for (i = obj->table_export_base; i < end; i++) {
                struct val val;
                table_get(ti, i, &val);
                if (val.u.funcref.func == fi) {
                        return i;
                }
                if (val.u.funcref.func == NULL) {
                        val.u.funcref.func = fi;
                        table_set(ti, i, &val);
                        return i;
                }
        }
        /*
         * this should never happen because dyld_allocate_table_for_obj
         * reserves enough table elements.
         *
         * however, assert(false) is not appropriate because modules
         * themselves can freely modify the table elements.
         */
        xlog_trace("dyld: failed to register a func");
        return 0;
}

__attribute__((unused)) static const char *
symtype_str(enum symtype symtype)
{
        switch (symtype) {
        case SYM_TYPE_FUNC:
                return "func";
        case SYM_TYPE_MEM:
                return "mem";
        }
        assert(false);
}

int
dyld_resolve_symbol_in_obj(struct dyld_object *refobj, struct dyld_object *obj,
                           enum symtype symtype, const struct name *sym,
                           uint32_t *resultp)
{
        struct dyld *d = refobj->dyld;
        enum externtype etype;
        if (symtype == SYM_TYPE_FUNC) {
                etype = EXTERNTYPE_FUNC;
        } else {
                etype = EXTERNTYPE_GLOBAL;
        }
        const struct module *m = obj->module;
        uint32_t idx;
        int ret;
        ret = module_find_export(m, sym, etype, &idx);
        if (ret != 0) {
                return ENOENT;
        }
        const struct instance *inst = obj->instance;
        uint32_t addr;
        if (symtype == SYM_TYPE_FUNC) {
                const struct funcinst *fi = VEC_ELEM(inst->funcs, idx);
                addr = dyld_register_funcinst(d, obj, fi);
        } else {
                struct globalinst *gi = VEC_ELEM(inst->globals, idx);
                if (!is_global_type_i32_const(gi->type)) {
                        return ENOENT;
                }
                /*
                 * TODO: consult WASM_DYLINK_EXPORT_INFO
                 * subsection to check TLS.
                 * for TLS, use __tls_base, not __memory_base.
                 */
                addr = global_get_i32(gi) + obj->memory_base;
        }
        xlog_trace("dyld: resolved %s %.*s %.*s -> %.*s idx %" PRIu32
                   " addr %08" PRIx32,
                   symtype_str(symtype), CSTR(refobj->name), CSTR(sym),
                   CSTR(obj->name), idx, addr);
        *resultp = addr;
        return 0;
}

int
dyld_resolve_symbol(struct dyld_object *refobj, enum symtype symtype,
                    const struct name *sym, uint32_t *resultp)
{
        struct dyld *d = refobj->dyld;
        struct dyld_object *obj;
        SLIST_FOREACH(obj, &d->objs, q) {
                int ret = dyld_resolve_symbol_in_obj(refobj, obj, symtype, sym,
                                                     resultp);
                if (ret == 0) {
                        return 0;
                }
        }
        if (is_binding_weak(refobj->module, sym)) {
                *resultp = 0;
                return 0;
        }
        return ENOENT;
}

static int
dyld_resolve_got_symbols(struct dyld_object *refobj)
{
        const struct module *m = refobj->module;
        struct globalinst *got = refobj->gots;
        int ret;
        xlog_trace("dyld: relocating %.*s", CSTR(refobj->name));
        uint32_t i;
        for (i = 0; i < m->nimports; i++) {
                const struct import *im = &m->imports[i];
                enum symtype symtype;
                if (is_GOT_mem_import(m, im)) {
                        symtype = SYM_TYPE_MEM;
                } else if (is_GOT_func_import(m, im)) {
                        symtype = SYM_TYPE_FUNC;
                } else {
                        continue;
                }
                uint32_t addr;
                ret = dyld_resolve_symbol(refobj, symtype, &im->name, &addr);
                if (ret != 0) {
                        xlog_error("dyld: failed to resolve %.*s %.*s %.*s",
                                   CSTR(refobj->name), CSTR(&im->module_name),
                                   CSTR(&im->name));
                        goto fail;
                }
                global_set_i32(got, addr);
                got++;
        }
        assert(got == refobj->gots + refobj->ngots);
        return 0;
fail:
        return ret;
}

static int
dyld_resolve_all_got_symbols(struct dyld *d, struct dyld_object *start)
{
        struct dyld_object *obj;
        for (obj = start; obj != NULL; obj = SLIST_NEXT(obj, q)) {
                int ret = dyld_resolve_got_symbols(obj);
                if (ret != 0) {
                        return ret;
                }
        }
        return 0;
}

static int
dyld_resolve_plt_symbols(struct dyld_object *refobj)
{
        struct mem_context *mctx = refobj->dyld->mctx;
        uint32_t i;
        for (i = 0; i < refobj->nplts; i++) {
                struct dyld_plt *plt = &refobj->plts[i];
                struct exec_context ectx;
                exec_context_init(&ectx, refobj->instance, mctx);
                int ret = dyld_resolve_plt(&ectx, plt);
                exec_context_clear(&ectx);
                if (ret != 0) {
                        if (!is_binding_weak(refobj->module, plt->sym)) {
                                xlog_error("dyld: failed to resolve plt "
                                           "eagerly %.*s %.*s",
                                           CSTR(refobj->name), CSTR(plt->sym));
                                return ret;
                        }
                        xlog_trace("dyld: failed to resolve plt eagerly %.*s "
                                   "%.*s (weak)",
                                   CSTR(refobj->name), CSTR(plt->sym));
                }
        }
        return 0;
}

static int
dyld_resolve_all_plt_symbols(struct dyld *d, struct dyld_object *start)
{
        struct dyld_object *obj;
        for (obj = start; obj != NULL; obj = SLIST_NEXT(obj, q)) {
                int ret = dyld_resolve_plt_symbols(obj);
                if (ret != 0) {
                        return ret;
                }
        }
        return 0;
}

int
dyld_resolve_dependencies(struct dyld *d, struct dyld_object *obj,
                          bool bindnow)
{
        int ret;
        ret = dyld_load_needed_objects(d, obj);
        if (ret != 0) {
                goto fail;
        }
        ret = dyld_resolve_all_got_symbols(d, obj);
        if (ret != 0) {
                goto fail;
        }
        if (bindnow) {
                ret = dyld_resolve_all_plt_symbols(d, obj);
                if (ret != 0) {
                        goto fail;
                }
        }
        return 0;
fail:
        return ret;
}

int
dyld_load(struct dyld *d, const char *filename)
{
        struct dyld_object *obj;
        int ret;

        d->shared_import_obj = d->opts.base_import_obj;
        ret = dyld_load_object_from_file(d, &name_main_object, filename, &obj);
        if (ret != 0) {
                goto fail;
        }
        ret = dyld_resolve_dependencies(d, obj, d->opts.bindnow);
        if (ret != 0) {
                goto fail;
        }
        if (d->pie) {
                ret = dyld_allocate_stack(d, d->opts.stack_size);
                if (ret != 0) {
                        goto fail;
                }
                ret = dyld_allocate_heap(d);
                if (ret != 0) {
                        goto fail;
                }
        } else {
#if defined(TOYWASM_ENABLE_TRACING)
                uint32_t sp = global_get_i32(d->stack_pointer);
#endif
                uint32_t base = global_get_i32(d->u.nonpie.heap_base);
                uint32_t end = global_get_i32(d->u.nonpie.heap_end);
                xlog_trace("dyld: globals from the non-pie main module sp "
                           "%08" PRIx32 " heap_base %08" PRIx32
                           " heap_end %08" PRIx32,
                           sp, base, end);

                /*
                 * Note: we don't share "__heap_base" from the main module
                 * as "GOT.mem __heap_base" directly because they are
                 * different on mutability. Instead, we copy their values
                 * here.
                 *
                 * when wasm-ld synthesizes GOT.mem/GOT.func imports,
                 * they are always mutable.
                 * cf.
                 * https://github.com/llvm/llvm-project/blob/a5ba6067d619b0dd5f7b660ff4658f9af43db556/lld/wasm/SyntheticSections.cpp#L294
                 *
                 * otoh, when wasm-ld exports DefinedData globals,
                 * they are always immutable.
                 * cf.
                 * https://github.com/llvm/llvm-project/blob/a5ba6067d619b0dd5f7b660ff4658f9af43db556/lld/wasm/SyntheticSections.cpp#L548
                 */
                global_set_i32(&d->heap_base, base);
                global_set_i32(&d->heap_end, end);
        }
        return 0;
fail:
        dyld_clear(d);
        return ret;
}

int
dyld_execute_init_funcs(struct dyld *d)
{
        struct dyld_object *obj = SLIST_FIRST(&d->objs);
        return dyld_execute_all_init_funcs(d, obj);
}

void
dyld_clear(struct dyld *d)
{
        struct mem_context *mctx = d->mctx;
        struct dyld_object *obj;
        while ((obj = SLIST_FIRST(&d->objs)) != NULL) {
                SLIST_REMOVE_HEAD(&d->objs, obj, q);
                dyld_object_destroy(obj);
        }
        if (d->pie) {
                if (d->meminst != NULL) {
                        memory_instance_destroy(mctx, d->meminst);
                }
                if (d->tableinst != NULL) {
                        table_instance_destroy(mctx, d->tableinst);
                }
        }
        struct import_object *imp;
        while ((imp = d->shared_import_obj) != d->opts.base_import_obj) {
                d->shared_import_obj = imp->next;
                import_object_destroy(mctx, imp);
        }
#if defined(TOYWASM_ENABLE_DYLD_DLFCN)
        struct dyld_dynamic_object *it;
        VEC_FOREACH(it, d->dynobjs) {
                size_t sz = strlen(it->name.data) + 1;
                mem_free(mctx, (void *)it->name.data, sz); /* discard const */
        }
        VEC_FREE(mctx, d->dynobjs);
#endif
#if defined(TOYWASM_ENABLE_WASM_EXCEPTION_HANDLING)
        if (d->c_longjmp_ft != NULL) {
                functype_free(mctx, d->c_longjmp_ft);
        }
#endif
        memset(d, 0, sizeof(*d));
}

struct instance *
dyld_main_object_instance(struct dyld *d)
{
        const struct dyld_object *obj = SLIST_FIRST(&d->objs);
        return obj->instance;
}

struct meminst *
dyld_memory(struct dyld *d)
{
        return d->meminst;
}

struct tableinst *
dyld_func_table(struct dyld *d)
{
        return d->tableinst;
}
